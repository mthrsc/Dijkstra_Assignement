package PathFinding;

import java.util.LinkedList;

/**
 *
 * @author Mattieu Roscio
 * PathFinding.java
 * 18 11 2020
 */
//PathFinding is gathering data generated by Dijkstra algorithm to print out the actual shortest path from source to destination
//It uses Path node objects (Path.java) which store node, previous node, and distance from source
public class PathFinding {

    private LinkedList<Path> allNodesList;
    private static LinkedList<Path> resultList;

    public PathFinding() {
        allNodesList = new LinkedList();
    }

    //Pathfinding create a new pathobject with the ID of the node, its distance from source and the ID of the previous node.
    public void addNode(int node, double distanceFromSource, int previousNode) {
        Path path = new Path(node, distanceFromSource, previousNode);

        //Does the node already exist ? Do we create a new one or update it
        //We can update safely since we know that Dijkstra will only be sending a new node if distanceFromSource is shorter
        int index = nodeAlreadyListed(path);

        if (index == -1) {
            allNodesList.add(path);
        } else if (index != -1) {
            allNodesList.set(index, path);
        }
    }

    int nodeAlreadyListed(Path path) {
        int index = -1;
        int node = path.getNode();
        for (int i = 0; i < allNodesList.size(); i++) {
            if (allNodesList.get(i).getNode() == node) {
                index = i;
                break;
            }
        }
        return index;
    }

    public void printListRaw() {
        System.out.println("\nprintListRaw" + " - p.size(): " + allNodesList.size());
        for (int i = 0; i < allNodesList.size(); i++) {
            System.out.println(allNodesList.get(i).toString());
        }
    }

    //PrintshortestPath creates a resultList that will contain the actual path to print
    //It will look for the destination in the original path LinkedList
    //createResultList is a recursion that looks at the first item previous node, and research it in the path LL
    //When found the "previous node" is added in first position of the resultList
    //The origin will always have a previous node of -1 which will stop the rec.
    //Then it is just loop / print
    public void printShortestPath(int source, int destination) {
        resultList = new LinkedList();
        for (int i = 0; i < allNodesList.size(); i++) {
            if (allNodesList.get(i).getNode() == destination) {
                resultList.add(allNodesList.get(i));
            }
        }
        createResultList(resultList);

        System.out.println("\nShortest path in " + (resultList.size() - 1) + " hops");
        for (int i = 0; i < resultList.size(); i++) {
            System.out.println(resultList.get(i).toString());
        }
    }

    //Same but without the print part
    public void getShortestPath(int source, int destination) {
        resultList = new LinkedList();
        for (int i = 0; i < allNodesList.size(); i++) {
            if (allNodesList.get(i).getNode() == destination) {
                resultList.add(allNodesList.get(i));
            }
        }
        createResultList(resultList);
    }

    //Path finding solve the path by starting from the destination
    //the list starts with the destination node and it predecessor
    //It will work its way to the source via recursion
    void createResultList(LinkedList<Path> resultList) {
        int previousNode = resultList.getFirst().getPreviousNode();
        if (previousNode == -1) {
            return;
        }
        for (int i = 0; i < allNodesList.size(); i++) {
            if (allNodesList.get(i).getNode() == previousNode) {
                resultList.addFirst(allNodesList.get(i));
            }
        }
        createResultList(resultList);
    }

    public LinkedList<Path> getResultList() {
        return resultList;
    }

}
